1.	Как явно получить адрес обычной переменной?
    int x = 5;
    std::cout << &x << '\n';
Можно ли получить адрес константы?:
#define g  9.8
cout<<g;
Нет, такое сделать нельзя, так как define является текстовой подстановкой константы. Она фактически не существует в памяти, у неё нет адреса.
Можно ли получить адрес типизированной константы?:
   const int g = 9;
cout<<g;
Да, можно, она выделяется в памяти и имеет адрес:
    const int nine = 9;
    std::cout << &nine << '\n';

2.	Проверить пример 
#include <iostream>
using namespace std;

int main() {
    // Проверить пример
    int b = 9;
    int *pb; // Объявили указатель
    pb = &b; // Присвоить адрес указателю

    cout << "b = " << b << " *pb = " << *pb << endl; // b=9, *pb=9
    cout << "pb = " << pb << " &b = " << &b << endl;

    *pb = *pb + 3; // Изменяем значение через указатель
    cout << "b = " << b << " *pb = " << *pb << endl; // b=12, *pb=12
}
В программе указатель pb ссылается на переменную b. Изменение значения через указатель также изменяет значение самой переменной.
 
3.	Что создается при таком объявлении?:
int* pb, pc;
Будет создан указатель pb и обычная переменная pc

4.	Проверьте sizeof (поясните):
char *c;
       cout<<sizeof(c);	double *c;
       cout<<sizeof(c);	char *c;
       cout<<sizeof(*c);
sizeof(c): 8 Байт
sizeof(d): 8 Байт
sizeof(*c): 1 Байт

Размер указателя фиксирован, но размер данных зависит от их типа, на которые ссылается указатель.

5.	При создании указателя компьютер выделяет память для хранения адреса, но не выделяет память для хранения данных на которые указывает адрес. Куда поместили значения в примере ниже?:
int *t;
*t=9;
Данные значения некуда помещать, в процессе выполнения программы произойдёт ошибка, так как t не инициализирован, необходимо выделить память следующим образом: int *t = new int;

6. Отличайте указатель от ссылки.
     Не бывает нулевых ссылок. Ссылка всегда ссылается на какой-то объект. Если переменная дает доступ к объекту, которого может не быть, то используйте указатель.
     Можно ли поступать так как в примере ниже:
     int &b?
	Нет, так как ссылка должна быть инициализирована при объявлении, например:
	int a = 9;
	int &b = a;

7. Ссылку можно назвать константным указателем, который автоматически разыменовывается компилятором. Проверить работу кода.
    int b =8;
    int &ref = b;
    ref++;
    cout<<"ref = "<<ref<<" b = "<<b;
    int &t0 = 90;//можно ли так?
    const int &t =45;//а так? – 
 cout<<t;

int &t0 = 90; Ссылка должна указывать на переменную, так делать нельзя
    const int &t =45; Так можно, потому что t будет являться ссылкой на константу

8. Изучите приведенный ниже код:
#include <iostream>
using namespace std;
void inc1(int *p)
{
    (*p)++;
}
void inc2(int &r)
{
    r++;
}
void inc3(int *& pr)//cсылка на указатель (если надо изменить содержимое самого указателя)
{
    pr++;
}
int main()
{
    int b = 8;
    cout<<"inc1:"<<b<<endl;
    inc1(&b);
    cout<<"inc1_:"<<b<<endl;
    inc2(b);
    cout<<"inc2:"<<b<<endl;
    int *c = &b;
    cout<<"c:"<<c<<endl;
    inc3(c);
    cout<<"c_:"<<c<<endl;
    }

(*p)++;   увеличение значения по указателю
r++;   увеличение по ссылке
pr++;   увеличение самого указателя

9. Инициализация указателя адресом участка динамической памяти
В чем отличие в приведенном ниже коде:
1.	int *p = new int (10);
2.	int *p = new int [10];
Покажите, как правильно освободить память для варианта 1 и 2.
	В первом примере выделяется память для одного целого числа (10). В втором примере выделяется массив из 10 элементов, но их значения ещё не инициализированы.
    int *p1 = new int(10);
    int *p2 = new int[10];

    delete p1;
    delete[] p2;

10. Указатель на указатель….Проверить работу кода:
    int b = 8;
    int *pb = &b;
    int **ppb = &pb;
    int ***pppb = &ppb;
    cout<<"value="<<b<<" address="<<&b<<endl;
    cout<<"value="<<*pb<<" address="<<&pb<<endl;
    cout<<"value="<<**ppb<<" address="<<&ppb<<endl;
    cout<<"value="<<***pppb<<" address="<<&pppb<<endl;
        cout<<pppb<<" "<<*pppb<<" "<<**pppb<<" "<<***pppb;
    b – переменная
    pb – указатель на переменную b
    ppb – указатель указателя на b
    pppb – указатель указателя указателя на б

11. На одну переменную может быть объявлено несколько ссылок?.
       Приведите пример.
    Да, на одну переменную можно быть объявлено несколько ссылок.
#include <iostream>
using namespace std;

int main() {

    int x = 10;
    int &ref1 = x;  // Первая ссылка
    int &ref2 = x;  // Вторая ссылка

    cout << "ref1 = " << ref1 << endl; // 10
    cout << "ref2 = " << ref2 << endl; // 10

    // Изменим значение через первую ссылку
    ref1 = 20;
    cout << "После изменения через ref1: x = " << x << endl; // 20
    cout << "ref1 = " << ref1 << endl; // 20
    cout << "ref2 = " << ref2 << endl; // 20
}

12. Можно ли определить указатель на ссылку?
    Нет, указатель на ссылку невозможен. Ссылки не занимают адрес в памяти, а лишь привязаны к уже существующему объекту.

13. Можно ли определить ссылку на ссылку?
    Нет, ссылку на ссылку определить нельзя. Ссылки не могут быть вложенными. Ссылки являются «псевдонимами» для объектов, а ссылка на ссылку не имеет логики.

14. Можно ли создать массив ссылок?
	Нет, массив ссылок создать нельзя. В массиве все элементы следуют в памяти друг за другом, а т.к. ссылка «не имеет веса», то к ней не обратиться с помощью массива.  

15. Приведите пример переназначения указателя другой переменной.

#include <iostream>
using namespace std;

int main() {
    int a = 5;
    int b = 10;
    int *ptr = &a;  // Указатель на a

    cout << "ptr указывает на a: " << *ptr << endl; // 5

    ptr = &b;  // Переназначение указателя на b
    cout << "ptr указывает на b: " << *ptr << endl; // 10
}



16. Использование ключевого слова const c указателями. Проверить работу кода
       1 вариант (адрес менять можно, а данные нет):
    int b = 8;
    const int* pb = &b;
    cout<<pb<<" "<<*pb<<endl;
    int c = 3;
    pb = &c;
    cout<<pb<<" "<<*pb<<endl;
    // *pb = 7; // Ошибка, так как нельзя изменить значение через указатель из-за того, что он постоянный
    cout<<pb<<" "<<*pb<<" "<<c<<endl;
        
       2 вариант (адрес постоянный, данные можно менять):
    int b = 8;
    int* const pb = &b;
    cout<<pb<<" "<<*pb<<endl;
    *pb=88;
    cout<<pb<<" "<<*pb<<endl;
    int c =55;
    // pb = &c; // Здесь произойдёт ошибка, так как нельзя изменить адрес из-за того, что он постоянный
    cout<<pb<<" "<<*pb<<endl;

       3 вариант (адрес и значение постоянные)
    int b = 8;
    const int* const pb = &b;
    cout<<pb<<" "<<*pb<<endl;
    // *pb=88; // Нельзя изменить значение, оно постоянное
    cout<<pb<<" "<<*pb<<endl;
    int c =55;
    // pb = &c; // Нельзя изменить адрес, он постоянный
    cout<<pb<<" "<<*pb<<endl;
